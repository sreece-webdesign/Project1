<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Gayathri:100|Lato:300" rel="stylesheet">
    <title>Demo</title>
    <link href="style.css" rel="stylesheet" type="text/css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
  * {
    box-sizing: border-box;
  }
  </style>
  </head>
  <body>
    <h3>Chapter 3:</h3><h1>Why are programmers so intense about languages?</h1><p>Many conferences are organized around specific programming languages or specific communities (PyCon for Python programmers; the Strata conference for big data; Oscon for open-source coders); these are ritual events for the people in those communities. Attendees gather, talk, and post the videos on YouTube. Language matters.

      Programmers track the success of computer languages the way other people track sports rankings, commenting on Web forums such as Reddit (where many languages get their own &ldquo;subreddit,&rdquo; and reddit.com/r/programming currently has 620,202 readers), or Hacker News, run by the venture capital firm Y Combinator (a company named after a special kind of function that operates on other functions), or Lambda the Ultimate (named after a series of papers written mostly in the 1970s about the influential programming language Scheme&mdash;the more inside-baseball the name, the nerdier the subject matter).

      There are hundreds of programming blogs. Many large corporations let their engineers blog (a generous gift, given how many recruiters are hovering). Discussions about programming go on everywhere, in public, at all times, about hundreds of languages. There is a keen sense of what&rsquo;s coming up and what&rsquo;s fading out.

      It&rsquo;s not simply fashion; one&rsquo;s career as a programmer depends on demonstrating capacity in one or more languages. So there are rankings, frequently updated, rarely shocking. As of April 15, the world&rsquo;s most-used computer languages, according to the Tiobe index (which uses a variety of indicators to generate a single ranking for the world of programming), are Java, C, C++, Objective-C, and C#, followed by JavaScript, PHP, and Python. The rankings are necessarily inexact; another list, by a consulting firm called RedMonk, gives JavaScript the top spot, followed by Java. There are many possible conclusions here, but the obvious one is that, all things being equal, a very good Java programmer who performs well in interviews will have more career options than a similar candidate using a more obscure language.

      If you code, by the time a language breaks through to the top 10 or 20, you&rsquo;ve heard of it, read blog posts about it, heard people lament how terrible or wonderful or misguided it is, possibly watched a few video tutorials, or played with it a little. Taking new languages out for a spin is a good thing for a programmer to do. Often all you have to do is download some files and write a couple lines of code, then decide if you want to go further. Most languages are free to download and use.

      Why do people construct and then give away free languages? Well, the creation of a good computer language is the work of an apex programmer. To have produced a successful language is acknowledged as a monumental effort, akin to publishing a multivolume history of a war, or fighting in one. The reward is glory.

      Changing a language is like fighting that war all over again, and some languages have at times been trapped in a liminal state between their old, busted selves, and their new, promised version. Perl 5, released in the mid-1990s, was a language uniquely suited to the World Wide Web, and it grew as the Web grew; Perl 6 was supposed to be better in every way, and a redesign began with grand pronouncements in 2000. But after 15 years of people working continually and often for free on a project they consider in the public interest, there&rsquo;s still no official Perl 6. (Latest ETA: Christmas 2015.)

      The Python language community, keenly aware of the Perl community&rsquo;s problems, decided to make necessary but difficult changes to the language as part of the transition from Version 2 to Version 3. They would modernize, clean up rough edges&mdash;but avoid grand reinventions. Development of Python 3.0 started in 2006; the first working version came out in 2008; and in 2015, the transition is ongoing.

      Making a new language is hard. Making a popular language is much harder still and requires the smile of fortune. And changing the way a popular language works appears to be one of the most difficult things humans can do, requiring years of coordination to make the standards align. Languages are large, complex, dynamic expressions of human culture.</p>
  <table class="center">
    <tr><td><h2>3.1: The Beauty of the Standard Library</h2><p>The true measure of a language isn&rsquo;t how it uses semicolons; it&rsquo;s the standard library of each language. A language is software for making software. The standard library is a set of premade software that you can reuse and reapply.<span id="dots"></span><span id="more">

    Take Python, which is &ldquo;batteries included,&rdquo; meaning that it comes with tons of  preexisting code, organized into  &ldquo;modules,&rdquo; that you can reuse. Its standard library has functions that let you copy Web pages or replace words in a document.

    What does that mean, to process text? Well, you might have a string of text (The Quick Brown Fox) and save it in a variable called my_string. So now you can call standard methods on that string. You can say my_string.lower(), and it will make all the words lowercase, producing &rsquo;the quick brown fox.&ldquo;

    Truly understanding a language&rsquo;s standard library is one of the ways one becomes proficient in that language. Typically you just visit Web pages or read a book.

    But the standard library is only the beginning. For many languages&mdash;and Python is exemplary&mdash;there&rsquo;s an enormous library of prewritten modules available for nearly instantaneous download, using &rsquo;package manager&ldquo; software. A module (or library, or package) is code that is intended to extend a language&rsquo;s capabilities.

    Let&rsquo;s say you work for an advertising agency and need to process through 100,000 pictures and scale and sharpen them.

    You type one command: sudo pip install Pillow, and the Pillow module is downloaded, compiled automatically, and placed into the correct directory for later reuse. You have to know, of course, that most modern languages have modules for image processing; you also need to know that Pillow is the most commonly used image-processing toolkit. Knowing how to find that out is part of the job of coding. You might learn it by Googling. You might ask a friend. You might get that information out of a book, or a website like The Hitchhiker&rsquo;s Guide to Python.

    A coder needs to be able to quickly examine and identify which giant, complex library is the one that&rsquo;s the most recently and actively updated and the best match for his or her current needs. A coder needs to be a good listener.

    But what a payoff! Now that Pillow is installed, you have, at your typing fingertips, dozens of routines and functions related to image processing that you can use in your code: change colors, rotate by a number of degrees, scale, convert GIF images to JPEGs, and so forth. Or if you need to do very complex numerical analysis and statistics work, you can download NumPy, and suddenly an enormous range of mathematical algorithms are available to you, hundreds of years of science and research boiled down. Audio processing, interacting with peculiar hardware, speaking to databases&mdash;there are packages for all of these things. But you need to know how to find them, what they are called. Code isn&rsquo;t just obscure commands in a file. It requires you to have a map in your head, to know where the good libraries, the best documentation, and the most helpful message boards are located. If you don&rsquo;t know where those things are, you will spend all of your time searching, instead of building cool new things
  </span></p>
    <button onclick="myFunction()" id="myBtn">Read More</button></td>
    <td><h2>3.2: What Do Different Languages Do?</h2><p>If all computer languages do the same thing... then why does it matter which one you choose? For the same reason that you wouldn&rsquo;t take a bicycle to pick up a fridge or get a physical from an oncological neurosurgeon.<span id="dots2"></span><span id="more">

       Some tools are better for certain jobs.It&rsquo;s possible for a C programmer and a Java programmer to read each other&rsquo;s code, but it&rsquo;s harder to make C code and Java code work together. C and Java represent the world in different ways, structure data in different ways, and address the components of the computer in different ways. There are true benefits to everyone on a team using the same language. They&rsquo;re all thinking the same way about how to instruct the computer to process data.

      It&rsquo;s not necessary for every team across a big organization to use the same language. In fact, it&rsquo;s often counterproductive. Large organizations have lots of needs and use many languages and services to meet them. For example, Etsy is built atop PHP&ndash;but its product&ndash;search service uses Java libraries, because the solutions for search available in Java are great.

      Some programming languages, such as C, will do their best to do exactly as you ask, even if that means crashing your computer. Others, like OCaml and Haskell, are very constrained and ask a programmer to hew to a narrow form, trying to steer you away from anything stupid.11

      Some languages have cute logos, like the Go gopher.

      There&rsquo;s Scratch, a teaching language for kids. It doesn&rsquo;t use text much at all but allows li&rsquo;l coders to move icons around on screen and assemble programs like Legos. Its logo is a smiling cat on two legs.

      And then there&rsquo;s Lisp, which didn&rsquo;t come with a logo when it was first proposed in the 1950s but now has a community&ndash;created five&ndash;eyed alien holding a flag with its proboscis. Lisp is a classic language. There are some languages that just have authority, elegance&mdash;canonical computer languages.

      And one of these is C. Most of the popular languages look a lot like it. C&rsquo;s de facto logo is, well, the letter C. C is called C because it came after another language. That language was called B.
      </span></p>
      <button onclick="myFunction2()" id="myBtn2">Read More</button></td>
    <td><h2>3.3: The Importance of C</h2><p>C is as big a deal as you can get in computing. Created by Dennis Ritchie starting in the late 1960s at Bell Labs, it&rsquo;s the principal development language of the UNIX operating system.<span id="dots3"></span><span id="more"> Unix (lowercased now, to refer to the idea of Unix instead of the branded version) is a simple operating system&mdash;basically it&rsquo;s a kernel12 that manages memory and runs software, a large collection of very small utility programs, and a &ldquo;shell&rdquo; that helps you knit programs into &ldquo;shell scripts.&rdquo; If you couldn&rsquo;t do what you needed with shell scripts, you might write a new utility in C and add it to the utility library. This was a nice and practical way of working, and it coincided with the rise of various kinds of networks that today we refer to collectively as the Internet. So Unix spread from Bell Labs to academia, to large industrial systems, and eventually leached into the water supply of computing until it was everywhere. And everywhere that Unix went, C was sure to go.

      C is a simple language, simple like a shotgun that can blow off your foot. It allows you to manage every last part of a computer&mdash;the memory, files, a hard drive&mdash;which is great if you&rsquo;re meticulous and dangerous if you&rsquo;re sloppy. Software made in C is known for being fast. When you compile C, it doesn&rsquo;t simply become a bunch of machine language in one go; there are many steps to making it really, ridiculously fast. These are called optimizations, and they are to programming what loopholes are to taxes. Think of C as sort of a plain&ndash;spoken grandfather who grew up trapping beavers and served in several wars but can still do 50 pullups.

      C&rsquo;s legendary, lucid manual and specification, The C Programming Language, written by Ritchie and Brian Kernighan (known by its nickname, K&R), is a quick and simple read&mdash;physically light in comparison with modern, heavy&ndash;stock guides to programming on bookstore shelves. This recommended text was published in 1978, when personal computing barely existed, back when a computer was a large piece of industrial equipment used to control a refrigeration system or calculate actuarial tables. It was in K&R that &ldquo;Hello, world!&rdquo; became the canonical example program for any language. By convention, almost every introduction to any programming language since then starts with a variation on &ldquo;Hello, world!&rdquo;
      </span></p>
      <button onclick="myFunction3()" id="myBtn3">Read More</button></td>
  </tr>
  <tr>
    <td><h2>3.4: The Corporate Object Revolution</h2><p>If you&rsquo;re going to understand how code works in a corporate environment, you need to understand what object-oriented programming is. There are many definitions. I&rsquo;ll wade in and provide my own and face the consequences.<span id="more">

     Object-oriented programming is, at its essence, a filing system for code. As anyone who&rsquo;s ever shared a networked folder&mdash;or organized a physical filing cabinet—knows, without a good shared filing system your office will implode. C, people said in the 1980s and &rsquo;90s, is a great language! An excellent language! But it doesn&rsquo;t really let you organize things. You end up with all these functions. It&rsquo;s a mess. I mean, we have this data structure for our customers (name, address, and so forth), and we have all these functions for manipulating that data (update_address, send_bill, delete_account), but the thing is, those functions aren&rsquo;t related to the data except by the naming convention. C doesn&rsquo;t have a consistent way to name things. Which means it&rsquo;s hard to find them later. Object&ndash;oriented prog&ndash;ramming gave programmers a great way to name things a means of building up a library. I could call (run) update_address on a picture of a dog or an Internet address. That approach is sloppy and dangerous and leads to bugs (our forebears reasoned, and not without precedent), and it makes it hard to program with big teams and keep track of everything.

      So what if, whaaaat if, we made a little box called Customer (call it a class, as in the taxonomical sense, like a Customer is a subclass of the species human, which is a subclass of mammal, etc.), and we put the data and methods relating to customers into that box. (And by box, it&rsquo;s literally just &ldquo;public class Customer {}&rdquo; and anything inside the {} relates to that particular class.)

      I mean, you wouldn&rsquo;t even need to look inside the box. You&rsquo;d just download a large set of classes, all nested inside one another, study the available, public methods and the expected data, and start programming. Hey, you&rsquo;d say, let&rsquo;s put some data into our object, take some data out. Every time we have a new customer we make a new instance of our class. Code can be a black box, with tentacles and wires sticking out, and you don&rsquo;t need to&mdash;don&rsquo;t want to&mdash;look inside the box. You can just put a couple of boxes next to each other, touch their tentacles together, and watch their eldritch mating.

      This works out very well, in theory.

      The archetypal object-oriented programming language is Smalltalk, created by a coterie of geniuses at Xerox PARC during that institution’s most glorious of glory days. After years of gestation, Smalltalk was born in 1972, the same year as C, and gelled around 1980. It was inspired by many of the big ideas in computer science, but also by Platonism, by cell biology, and by a predecessor language called Simula, the first object-oriented language, which per its name was designed to simulate things. While C was created within the New Jersey research facilities (Bell Labs) of an industrial monolith (AT&T) to solve problems at hand, Smalltalk was built at the far-off California outpost of a different industrial monolith, Xerox, to solve the problems of the distant future. Thus Smalltalk represents the world differently than C.

      Smalltalk has a funny name and a friendly attitude, but its specification ran to 700 pages. It was a big system. C gave you an abstraction over the entire computer, helping you manage memory and processes inside the machine. Smalltalk gave you an abstraction over all of reality, so you could start dividing the world into classes and methods and the like. Where C tried to make it easier to do computer things, Smalltalk tried to make it easier to do human things.

      This isn&rsquo;t better or worse. It&rsquo;s just different. Here is some Smalltalk code:

      Transcript show: 'Hello, world!.'
      It prints that short sentence in the Transcript Window on the user&rsquo;s screen. The Transcript is an object&mdash;and here it&rsquo;s receiving a message (show:) with an argument&mdash;i.e., input&ndash;&ldquo;Hello,&rdquo; etc. You type that in, select it with your mouse (even in the early 1980s), and tell the computer to execute it. It compiles just that bit of code and adds it to the rest of the running system. It looks like this:

      Screenshot of the Smalltalk programming environment
      Tons of windows all talking to each other. Each window is, well, an object. And instead of programming it and compiling the program, then running it, you just dive right into this living, breathing, window-full environment, and start making new objects that send messages to other objects. If you save where you are, and come back five years later, well, everything will look exactly the same.
      The thing is, all those boxes can be manipulated. They&rsquo;re all objects. It&rsquo;s almost too powerful: The boundaries that are clear in most languages, between data and code, between files and executables, between the operating system and applications, between closed and open software&mdash;all of those borders are fuzzed by design. Smalltalk is a vision of the computer as its own, native medium. The whole system can be modified, by anyone. The dominant version is called Squeak (logo: cute mouse), and a modernized version is called Pharo (logo: lighthouse). Both are free and easy to download.

      As a middling programmer I find the Smalltalk environment fascinating, but it never pulls me all the way through the looking glass. One day, I&rsquo;ve promised myself, I’ll read (or skim with intent) the huge Smalltalk specification from the 1980s&mdash;a seminal text and a grand attempt to organize reality along computer principles. The problem is that Smalltalk requires one to adopt not just a method of working but also a philosophy of the world, where everything is organized in a hierarchy of classes. I love to play with it, but I typically stumble back to more familiar approaches. Being an advocate for Smalltalk is a little like being very into Slovenian cinema or free jazz. Some of its advocates are particularly brilliant people. I&rsquo;m not one of them.

      Smalltalk&rsquo;s history is often described as slightly tragic, because many of its best ideas never permeated the culture of code. But it&rsquo;s still around, still has users, and anyone can use Squeak or Pharo. Also&mdash;

      Java is an object-oriented language, influenced by C++, that runs on a virtual machine (just like Smalltalk).
      Objective&ndash;C, per its name, jammed C and Smalltalk together with no apologies.
      C# (pronounced &ldquo;C sharp&rdquo;) is based on C and influenced by Java, but it was created by Microsoft for use in its .NET framework.
      C++ is an object-oriented version of C, although its roots are more in Simula.
      The number of digital things conceived in 1972 that are still under regular discussion is quite small. (It was the year of The Godfather and Al Green&rsquo;s Let&rsquo;s Stay Together.) The world corrupts the pure vision of great ideas. I pronounce Smalltalk a raging, wild, global success.
  </span></p>
    <button onclick="myFunction4()" id="myBtn4">Read More</button></td>
    <td><h2>3.5: Look How Big and Weird Things Get With Just Python</h2><p>Python is a very interesting language and quite popular, too. It&rsquo;s object-oriented but not rigid. And it&rsquo;s widely understood to be easier than C for programmers to use, because it provides more abstractions for programmers to reuse.<span id="more">

      It hides much of the weirdness of the computer and many details of how computation is performed. Python is usually slower than C; this is the price you pay for all those sweet levels of abstraction. In the vast majority of cases this difference in speed truly doesn&rsquo;t matter, regardless of how much people protest. It&rsquo;s only of consequence when you’ve built up a system in Python and a part of it runs millions or billions of times, slowing down the computer&mdash;and thus requiring more resources to get its work done.

      What then? Does this mean you need to throw away all your Python and start over in some other language? Probably not. Python has a deserved reputation as a 'glue language,' meaning you can take code from other, lower&ndash;level languages such as C, C++, and Fortran 77 (yes, as in the year 1977), code that is close to the machine and known to be sound, and write 'wrapper functions.' That is, you can embed the older, faster code in the newer, slower, but easier-to-use system.

      A big part of this process is in wrapping up the old code in nice, well&mdash;organized Python functions. In many ways the idiom of a language is not just how it looks but also how it feels. Some languages emphasize brevity. Some support long, complex functions, while others encourage you to break up functionality into small pieces. Style and usage matter; sometimes programmers recommend Strunk & White&rsquo;s The Elements of Style&mdash;that&rsquo;s right, the one about the English language. Its focus on efficient usage resonates with programmers. The idiom of a language is part of its communal identity.

      Python is not the glue for everything, though. It&rsquo;s hard to connect to Java but fits C hand to glove. There&rsquo;s a version of Python designed to run inside of Java and use Java code. That&rsquo;s called Jython. If you want a version that works with Microsoft&rsquo;s .NET, you can go with IronPython.

      But there&rsquo;s another way to interpret all this activity around Python: People love it and want it to work everywhere and do everything. They&rsquo;ve spent tens of thousands of hours making that possible and then given the fruit of their labor away. That&rsquo;s a powerful indicator. A huge amount of effort has gone into making Python practical as well as pleasurable to use. There are lots of conferences, frequent code updates, and vibrant mailing lists. You pick a language not just on its technical merits, or its speediness, or the job opportunities it may present, but also on its culture.

      Python people, generally, are pretty cool.
  </span></p>
    <button onclick="myFunction5()" id="myBtn5">Read More</button></td>
    <td><h2>Chapter 4: Why Are Coders Angry?</h2><p>There&rsquo;s a website dedicated to language benchmarks, to measuring how fast certain languages run compared with others, and it includes this preface to stave off riots: &ldquo;...These are just 10 tiny examples.&rdquo;</p>
    <button id="myBtn6">Next Page</button></td>
  </tr>
</table>
      <br>
      <p>Paul Ford is a writer and programmer who lives in Brooklyn, N.Y. He is a founding partner of Postlight, a company in New York City that builds Internet platforms and develops interactive products. He is writing a book of essays about Web pages that Farrar, Straus and Giroux will publish in 2016. His article, &ldquo;The Surprising Sophistication of Twitter,&rdquo; appeared in the Nov. 7, 2013, issue of Bloomberg Businessweek.

      <font color=#AFAFAF>Email: ford@ftrain.com | Twitter: @ftrain | GitHub: ftrain</font></p>
  </body>
  </html>

  <script>
  function myFunction() {
    var dots = document.getElementById("dots");
    var moreText = document.getElementById("more");
    var btnText = document.getElementById("myBtn");

    if (dots.style.display === "none") {
      dots.style.display = "inline";
      btnText.innerHTML = "Read more";
      moreText.style.display = "none";
    } else {
      dots.style.display = "none";
      btnText.innerHTML = "Read less";
      moreText.style.display = "inline";
    }
  }
  function myFunction2() {
    var dots = document.getElementById("dots2");
    var moreText = document.getElementById("more2");
    var btnText = document.getElementById("myBtn2");

    if (dots.style.display === "none") {
      dots.style.display = "inline";
      btnText.innerHTML = "Read More";
      moreText.style.display = "none";
    } else {
      dots.style.display = "none";
      btnText.innerHTML = "Read Less";
      moreText.style.display = "inline";
    }
  }

  function myFunction3() {
    var dots = document.getElementById("dots3");
    var moreText = document.getElementById("more3");
    var btnText = document.getElementById("myBtn3");

    if (dots.style.display === "none") {
      dots.style.display = "inline";
      btnText.innerHTML = "Read More";
      moreText.style.display = "none";
    } else {
      dots.style.display = "none";
      btnText.innerHTML = "Read Less";
      moreText.style.display = "inline";
    }
  }

  function myFunction4() {
    var dots = document.getElementById("dots");
    var moreText = document.getElementById("more4");
    var btnText = document.getElementById("myBtn4");

    if (dots.style.display === "none") {
      dots.style.display = "inline";
      btnText.innerHTML = "Read More";
      moreText.style.display = "none";
    } else {
      dots.style.display = "none";
      btnText.innerHTML = "Read Less";
      moreText.style.display = "inline";
    }
  }

  function myFunction5() {
    var dots = document.getElementById("dots");
    var moreText = document.getElementById("more5");
    var btnText = document.getElementById("myBtn5");

    if (dots.style.display === "none") {
      dots.style.display = "inline";
      btnText.innerHTML = "Read More";
      moreText.style.display = "none";
    } else {
      dots.style.display = "none";
      btnText.innerHTML = "Read Less";
      moreText.style.display = "inline";
    }
  }

  </script>
